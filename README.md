 -- 프로젝트 세팅 절차 
  - runtime: node -v22.20.0
  - db: mysql -v8.0.43v
      - user: root
      - pw: temp00!
      - dbName: temperature [CREATE DATABASE temperature;]
      - db시간 세팅: [SET GLOBAL time_zone = '+09:00;]

1. 위 환경을 로컬 환경에 구축 해주세요
2. 프로젝트를 checkout 후, 해당 디렉토리의 터미널을 오픈 npm install으로 패키지를 받아주세요
3. src 경로로 이동, cli로 npx knex migrate:latest 로 스키마 세팅을 진행 해주세요 
4. npm run start로 작동. port는 기본 3000입니다.
5. localhost:3000/api로 접속 해주세요. swagger를 통해 테스트가 가능 합니다(별도의 권한 처리는 당연 하지 않았습니다)
    5-1. deviceGroupCode 등록 
    5-2. deviceCode 등록
    5-3. device 온도 기록 등록
    5-4. device 통계 조회
    5-5. deviceGroup통계 조회


=====================================
    구현 구조의 의도와 목적
=====================================
 o 스키마 빌더는 아래의 장점으로 사용 했습니다.
    - 서버 개발자가 스키마 형상관리 가능
    - 여러 영역에 스키마 구조 동시적용 편리
    - 대체로 초안을 dbClient에서 수행 후, 완료된 작업 스크립트를 schemaBuilder에 저장 및 push.

o 중복 기능 대응
    - 장비가 중복 요청을 보내는 경우로 이해 했습니다. deviceId와 시간이 동일하면 후속 작업을 무시하도록 합니다

o 성능 최적화(대용량 I/O)
    - IOT는 대량의 read와 write가 특징이므로 둘 다 고려해야 한다고 판단 했습니다.
    - log 테이블의 autoIncrement + 보조 키는 관측 시간-장비 id 순으로 편성해서 정렬 효율을 올려 write에 유리하도록 구성 했습니다
    - 보조 키는 장비별 색인 처리인 '측정 시간-장비번호'에 적합 하도록 멀티인덱스로 구성 했습니다.
    - 장비 그룹별 통계 조회를 위해서는 FK등록 정도만 추가 했습니다. 2차 보조 멀티 인덱스는 구성하지 않았습니다.
    - partition은 배제 했습니다. 제시된 과제 규모에는 너무 크고, 해당 규모라면 FK를 가져가는게 더 유리하다고 판단 했습니다

o 테스트
    - controller에 입력 되는 값을 정적으로 확인하는 unitTest만 구성했습니다.
    - unitTest의 핵심은 항상 동일한 입력에 항상 동일한 출력을 보장한다 라고 생각합니다.
    - 하지만 service영역은 계산 중심이 아닌 데이터(혹은 도메인)중심의 판단이 우선 됩니다.
        ex:: groupCode 'a1'은 최초 입력시 에는 성공하지만, 중복 입력은 의도적으로 예외를 던집니다.
            동일 입력에 상이한 결과지만, 이는 의도된 기능이며 오류로 볼 수 없습니다.
    - 따라서 service부터는 순서의 영향을 크게 받는 시나리오 기반의 E2E 테스트가 더욱 적합 하다고 판단 했습니다.
    - 이는 이번 과제의 범위를 벗어나기 때문에 unitTest는 request값을 검사하는 수준에서 마쳤습니다.

o 데이터 모델의 명명 규칙
    - dto: 입력과 출력을 구분하기 위해 request와 response의 약자를 중간자를 추가 했습니다.
    - dao: entity로 대체 했습니다. queryBuilder에게 테이블 구조를 지네릭스로 알려주면 쿼리 작성시
        컬럼명을 알려줘 오타를 줄일 수 있기 때문에 entity를 만들고, CUD작업이 진행될 때는 해당 entity와 호환 했습니다
    - vo: 대체로 VO는 select절과 맞춰 사용되고, select절은 매번 쿼리마다 거의 항상 만들어 지므로
        단일 파일에 interface를 몰아서 만들어 뒀습니다(혹은 type). qb계층에 필요시 마다 즉시 구현도 좋긴 한데
        시간이 지나면 해당 vo를 다른 곳에서 참조 하면 의존 구조가 복잡해져서 model은 독립 파일로 보관이 깔끔할듯 해서 분리 했습니다.

o 그 외 고려 사항
    - 서버의 가장 취약점인 경계 지점에서 타입 추론을 확정할 수 있는 부분을 최대한 신경 써봤습니다
    - db의 반환값과 request는 IDE의 추론 범위를 벗어나기 때문에 항상 가장 취약한 부분이라 생각 합니다.